<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My First Post | marcelarie</title>
<meta name="keywords" content="" />
<meta name="description" content="What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn&rsquo;t work like that, all the communication that we do today its asynchronous.
So for example this will be synchronous code:
fn synchronous_hello() { println!(&#34;hello!&#34;); } fn main() { let hello = synchronous_hello(); // &#34;hello!&#34; gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!">
<meta name="author" content="">
<link rel="canonical" href="http://marcelarie.github.io/posts/my-first-post/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css" integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw&#43;W8mWdq36u97PLc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://marcelarie.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://marcelarie.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://marcelarie.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://marcelarie.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://marcelarie.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="My First Post" />
<meta property="og:description" content="What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn&rsquo;t work like that, all the communication that we do today its asynchronous.
So for example this will be synchronous code:
fn synchronous_hello() { println!(&#34;hello!&#34;); } fn main() { let hello = synchronous_hello(); // &#34;hello!&#34; gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://marcelarie.github.io/posts/my-first-post/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-01T22:57:26&#43;02:00" />
<meta property="article:modified_time" content="2021-10-01T22:57:26&#43;02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My First Post"/>
<meta name="twitter:description" content="What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn&rsquo;t work like that, all the communication that we do today its asynchronous.
So for example this will be synchronous code:
fn synchronous_hello() { println!(&#34;hello!&#34;); } fn main() { let hello = synchronous_hello(); // &#34;hello!&#34; gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://marcelarie.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "My First Post",
      "item": "http://marcelarie.github.io/posts/my-first-post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "My First Post",
  "name": "My First Post",
  "description": "What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn\u0026rsquo;t work like that, all the communication that we do today its asynchronous.\nSo for example this will be synchronous code:\nfn synchronous_hello() { println!(\u0026#34;hello!\u0026#34;); } fn main() { let hello = synchronous_hello(); // \u0026#34;hello!\u0026#34; gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!",
  "keywords": [
    
  ],
  "articleBody": "What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn’t work like that, all the communication that we do today its asynchronous.\nSo for example this will be synchronous code:\nfn synchronous_hello() { println!(\"hello!\"); } fn main() { let hello = synchronous_hello(); // \"hello!\" gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!(\"hello!\"); } fn main() { let hello_for_later = asynchronous_hello(); // Nothing gets printed  // ... ton of more code that can be run here  block_on(hello_for_later); // \"hello!\" gets printed } So with that you are set for the rest of the post, async-await makes it easy to write asynchronous code. Rust it’s not a mature language so for some time didn’t have the async-await syntax.\nBut now we got it, and we gonna learn together, myself included, how it works!\nWhat I need to make my rust code asynchronous ? To create asynchronous functions you just need to add the async keyword before the function.\nasync fn return_ten() - u64 { 10 } To run that code you will need an executor or the await keyword. For that we will use the futures library. That comes with multiple abstractions to work with async-await. Here you have an example of both methods:\n[dependencies] futures = \"0.3\" use futures::executor::block_on; async fn return_ten() - u64 { 10 } async fn await_for_ten_or_return_zero() - u64 { if return_ten().await == 10 { 10 } else { 0 //  } } fn main() { let ten = block_on(await_for_ten()); println!(\"Finally {} !\", ten) // \"Finally 10 !\" is printed } We are using the block_on executor on the main function because the await keyword can only be used inside async functions. await_for_ten_or_return_zero needs, like the name says, to execute return_ten first to compare it. So we use await to get the result from the asynchronous call. We can use the block_on executor wherever we want.\nThere are other executors that let us do more stuff than blocking the current thread until the futures completes. For example futures::join will get multiple futures, run them concurrently and return a tuple with the results in order:\nuse futures::join; async fn a_and_b() { // join! just works inside async functions  let a = async { 'a' }; let b = async { 'b' }; join!(a, b); // ('a', 'b')  } One thing to mentoin is that in Rust the async-await implementation it’s lazy, that means that the code will not run on the background and wait for the await, but rather run at the moment the await call asks for it. This design follows the Rust philoshopy having a better performance and error handeling.\nSo that’s it ? Well, that can be it with the basics but you have a lot more options to work asynchronously in Rust. You have multiple frameworks/runtimes, none of them are standard:\n Tokio : A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std : A crate that provides asynchronous counterparts to standard library components. smol : A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like UnixStream or TcpListener.  Each one of them have different approaches, I will choose tokio because it’s the more one that looks more popular and standard.\nCrawler boilerplatte To create a basic crawler we need the following:\n Make HTTP calls Parse HTML code Async calls system  We will be using reqwest  for the HTTP calls, html5ever  for the parsing and tokio  for the async calls.\n[dependencies] reqwest = { version = \"0.11\" } html5ever = \"*\" tokio = { version = \"1\", features = [\"full\"] } ",
  "wordCount" : "629",
  "inLanguage": "en",
  "datePublished": "2021-10-01T22:57:26+02:00",
  "dateModified": "2021-10-01T22:57:26+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://marcelarie.github.io/posts/my-first-post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "marcelarie",
    "logo": {
      "@type": "ImageObject",
      "url": "http://marcelarie.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://marcelarie.github.io/" accesskey="h" title="marcelarie (Alt + H)">marcelarie</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      My First Post
    </h1>
    <div class="post-meta">October 1, 2021
</div>
  </header> 
  <div class="post-content"><h3 id="what-is-async-await-">What is async-await ?<a hidden class="anchor" aria-hidden="true" href="#what-is-async-await-">#</a></h3>
<p>If you just started programming async-await may feel a strange concept. For now
you write code in a file and it runs in order, that is it right? But the web
doesn&rsquo;t work like that, all the communication that we do today its asynchronous.</p>
<p>So for example this will be synchronous code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">synchronous_hello</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello!&#34;</span>);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> hello <span style="color:#f92672">=</span> synchronous_hello(); <span style="color:#75715e">// &#34;hello!&#34; gets printed
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> futures::executor::block_on; <span style="color:#75715e">// we talk about this later :)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">asynchronous_hello</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hello!&#34;</span>);
}


<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> hello_for_later <span style="color:#f92672">=</span> asynchronous_hello(); <span style="color:#75715e">// Nothing gets printed
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// ... ton of more code that can be run here
</span><span style="color:#75715e"></span>    block_on(hello_for_later); <span style="color:#75715e">// &#34;hello!&#34; gets printed
</span><span style="color:#75715e"></span>}
</code></pre></div><p>So with that you are set for the rest of the post, async-await makes it easy to
write asynchronous code. Rust it&rsquo;s not a mature language so for some time didn&rsquo;t
have the async-await syntax.</p>
<p>But now we got it, and we gonna learn together, myself included, how it works!</p>
<h3 id="what-i-need-to-make-my-rust-code-asynchronous-">What I need to make my rust code asynchronous ?<a hidden class="anchor" aria-hidden="true" href="#what-i-need-to-make-my-rust-code-asynchronous-">#</a></h3>
<p>To create asynchronous functions you just need to add the <code>async</code> keyword before the function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">return_ten</span>() -&gt; <span style="color:#66d9ef">u64</span> { <span style="color:#ae81ff">10</span> }
</code></pre></div><p>To run that code you will need an executor or the await keyword. For that we will use the futures library. That comes with multiple abstractions to work with async-await. Here you have an example of both methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[<span style="color:#a6e22e">dependencies</span>]

<span style="color:#a6e22e">futures</span> = <span style="color:#e6db74">&#34;0.3&#34;</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> futures::executor::block_on;

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">return_ten</span>() -&gt; <span style="color:#66d9ef">u64</span> { <span style="color:#ae81ff">10</span> }

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">await_for_ten_or_return_zero</span>() -&gt; <span style="color:#66d9ef">u64</span> {
    <span style="color:#66d9ef">if</span> return_ten().<span style="color:#66d9ef">await</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span> {
        <span style="color:#ae81ff">10</span>
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#ae81ff">0</span> <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
   <span style="color:#66d9ef">let</span> ten <span style="color:#f92672">=</span> block_on(await_for_ten());
   println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Finally {} !&#34;</span>, ten) <span style="color:#75715e">// &#34;Finally 10 !&#34; is printed
</span><span style="color:#75715e"></span>}
</code></pre></div><p>We are using the <code>block_on</code> executor on the main function because the await keyword
can only be used inside async functions. <code>await_for_ten_or_return_zero</code> needs,
like the name says, to execute return_ten first to compare it. So we use await
to get the result from the asynchronous call.
We can use the <code>block_on</code> executor wherever we want.</p>
<p>There are other executors that let us do more stuff than blocking the current
thread until the <code>futures</code> completes. For example <code>futures::join</code> will get multiple
futures, run them concurrently and return a tuple with the results in order:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> futures::join;

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">a_and_b</span>() {        <span style="color:#75715e">// join! just works inside async functions
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> { <span style="color:#e6db74">&#39;a&#39;</span> };
    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> { <span style="color:#e6db74">&#39;b&#39;</span> };
    join<span style="color:#f92672">!</span>(a, b); <span style="color:#75715e">// (&#39;a&#39;, &#39;b&#39;)
</span><span style="color:#75715e"></span>
}
</code></pre></div><p>One thing to mentoin is that in Rust the async-await implementation it&rsquo;s lazy,
that means that the code will not run on the background and wait for the await,
but rather run at the moment the await call asks for it. This design follows the
Rust philoshopy having a better performance and error handeling.</p>
<h4 id="so-thats-it-">So that&rsquo;s it ?<a hidden class="anchor" aria-hidden="true" href="#so-thats-it-">#</a></h4>
<p>Well, that can be it with the basics but you have a lot more options to work
asynchronously in Rust. You have multiple frameworks/runtimes, none of them are
standard:</p>
<ol>
<li><a href="https://github.com/tokio-rs/tokio"> Tokio </a>: A popular async ecosystem with HTTP, gRPC, and tracing frameworks.</li>
<li><a href="https://github.com/async-rs/async-std"> async-std </a>: A crate that provides asynchronous counterparts to standard library components.</li>
<li><a href="https://github.com/smol-rs/smol"> smol </a>: A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like UnixStream or TcpListener.</li>
</ol>
<p>Each one of them have different approaches, I will choose tokio because it&rsquo;s the
more one that looks more popular and standard.</p>
<h3 id="crawler-boilerplatte">Crawler boilerplatte<a hidden class="anchor" aria-hidden="true" href="#crawler-boilerplatte">#</a></h3>
<p>To create a basic crawler we need the following:</p>
<ul>
<li>Make HTTP calls</li>
<li>Parse HTML code</li>
<li>Async calls system</li>
</ul>
<p>We will be using <a href="https://github.com/seanmonstar/reqwest"> reqwest </a> for the HTTP calls,
<a href="https://github.com/servo/html5ever"> html5ever </a> for the parsing and <a href="https://github.com/tokio-rs/tokio"> tokio </a>
for the async calls.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[<span style="color:#a6e22e">dependencies</span>]

<span style="color:#a6e22e">reqwest</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.11&#34;</span> }
<span style="color:#a6e22e">html5ever</span> = <span style="color:#e6db74">&#34;*&#34;</span>
<span style="color:#a6e22e">tokio</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;full&#34;</span>] }
</code></pre></div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="http://marcelarie.github.io/">marcelarie</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
