[{"content":"What is async-await ? If you just started programming async-await may feel a strange concept.\nFor now you write code in a file and it runs in order, that is it right? But the web doesn\u0026rsquo;t work like that, all the communication that we do today its asynchronous.\nSo for example this will be synchronous code:\n1 2 3 4 5 6 7  fn synchronous_hello(){println!(\u0026#34;hello!\u0026#34;);}fn main(){lethello=synchronous_hello();// \u0026#34;hello!\u0026#34; gets printed }  1 2 3 4 5 6 7 8 9 10 11 12  usefutures::executor::block_on;// we talk about this later :) asyncfn asynchronous_hello(){println!(\u0026#34;hello!\u0026#34;);}fn main(){lethello_for_later=asynchronous_hello();// Nothing gets printed // ... ton of more code that can be run here block_on(hello_for_later);// \u0026#34;hello!\u0026#34; gets printed }  So with that you are set for the rest of the post, async-await makes it easy to write asynchronous code. Rust it\u0026rsquo;s not a mature language so for some time didn\u0026rsquo;t have the async-await syntax.\nBut now we got it, and we gonna learn together, myself included, how it works!\nWhat I need to make my rust code asynchronous ? To create asynchronous functions you just need to add the async keyword before the function.\n1  asyncfn return_ten()-\u0026gt; u64 {10}  To run that code you will need an executor or the await keyword. For that we will use the futures library. That comes with multiple abstractions to work with async-await. Here you have an example of both methods:\n1 2  [dependencies] futures = \u0026#34;0.3\u0026#34;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  usefutures::executor::block_on;asyncfn return_ten()-\u0026gt; u64 {10}asyncfn await_for_ten_or_return_zero()-\u0026gt; u64 {ifreturn_ten().await==10{10}else{0}}fn main(){letten=block_on(await_for_ten());println!(\u0026#34;Finally {} !\u0026#34;,ten)// \u0026#34;Finally 10 !\u0026#34; is printed }  We are using the block_on executor on the main function because the await keyword can only be used inside async functions. await_for_ten_or_return_zero needs, like the name says, to execute return_ten first to compare it. So we use await to get the result from the asynchronous call. We can use the block_on executor wherever we want.\nThere are other executors that let us do more stuff than blocking the current thread until the futures completes. For example futures::join will get multiple futures, run them concurrently and return a tuple with the results in order:\n1 2 3 4 5 6 7  usefutures::join;asyncfn a_and_b(){// join! just works inside async functions leta=async{\u0026#39;a\u0026#39;};letb=async{\u0026#39;b\u0026#39;};join!(a,b);// (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) }  One thing to mentoin is that in Rust the async-await implementation it\u0026rsquo;s lazy, that means that the code will not run on the background and wait for the await, but rather run at the moment the await call asks for it. This design follows the Rust philoshopy having a better performance and error handeling.\nSo that\u0026rsquo;s it ? Well, that can be it with the basics but you have a lot more options to work asynchronously in Rust. You have multiple frameworks/runtimes, none of them are standard:\n Tokio : A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std : A crate that provides asynchronous counterparts to standard library components. smol : A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like UnixStream or TcpListener.  Each one of them have different approaches, I will choose tokio because it\u0026rsquo;s the more one that looks more popular and standard.\nCrawler boilerplatte To create a basic crawler we need the following:\n Make HTTP calls Parse HTML code Async calls system  We will be using reqwest  for the HTTP calls, html5ever  for the parsing and tokio  for the async calls.\n1 2 3 4  [dependencies] reqwest = { version = \u0026#34;0.11\u0026#34; } html5ever = \u0026#34;*\u0026#34; tokio = { version = \u0026#34;1\u0026#34;, features = [\u0026#34;full\u0026#34;] }   ","permalink":"http://marcelarie.github.io/posts/my-first-post/","summary":"What is async-await ? If you just started programming async-await may feel a strange concept.\nFor now you write code in a file and it runs in order, that is it right? But the web doesn\u0026rsquo;t work like that, all the communication that we do today its asynchronous.\nSo for example this will be synchronous code:\n1 2 3 4 5 6 7  fn synchronous_hello(){println!(\u0026#34;hello!\u0026#34;);}fn main(){lethello=synchronous_hello();// \u0026#34;hello!\u0026#34; gets printed }  1 2 3 4 5 6 7 8 9 10 11 12  usefutures::executor::block_on;// we talk about this later :) asyncfn asynchronous_hello(){println!","title":"Learn Async/Await in Rust creating a Web Crawler"}]