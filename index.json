[{"content":"What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn\u0026rsquo;t work like that, all the communication that we do today its asynchronous.\nSo for example this will be synchronous code:\nfn synchronous_hello() { println!(\u0026#34;hello!\u0026#34;); } fn main() { let hello = synchronous_hello(); // \u0026#34;hello!\u0026#34; gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!(\u0026#34;hello!\u0026#34;); } fn main() { let hello_for_later = asynchronous_hello(); // Nothing gets printed  // ... ton of more code that can be run here  block_on(hello_for_later); // \u0026#34;hello!\u0026#34; gets printed } So with that you are set for the rest of the post, async-await makes it easy to write asynchronous code. Rust it\u0026rsquo;s not a mature language so for some time didn\u0026rsquo;t have the async-await syntax.\nBut now we got it, and we gonna learn together, myself included, how it works!\nWhat I need to make my rust code asynchronous ? To create asynchronous functions you just need to add the async keyword before the function.\nasync fn return_ten() -\u0026gt; u64 { 10 } To run that code you will need an executor or the await keyword. For that we will use the futures library. That comes with multiple abstractions to work with async-await. Here you have an example of both methods:\n[dependencies] futures = \u0026#34;0.3\u0026#34; use futures::executor::block_on; async fn return_ten() -\u0026gt; u64 { 10 } async fn await_for_ten_or_return_zero() -\u0026gt; u64 { if return_ten().await == 10 { 10 } else { 0 //  } } fn main() { let ten = block_on(await_for_ten()); println!(\u0026#34;Finally {} !\u0026#34;, ten) // \u0026#34;Finally 10 !\u0026#34; is printed } We are using the block_on executor on the main function because the await keyword can only be used inside async functions. await_for_ten_or_return_zero needs, like the name says, to execute return_ten first to compare it. So we use await to get the result from the asynchronous call. We can use the block_on executor wherever we want.\nThere are other executors that let us do more stuff than blocking the current thread until the futures completes. For example futures::join will get multiple futures, run them concurrently and return a tuple with the results in order:\nuse futures::join; async fn a_and_b() { // join! just works inside async functions  let a = async { \u0026#39;a\u0026#39; }; let b = async { \u0026#39;b\u0026#39; }; join!(a, b); // (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)  } One thing to mentoin is that in Rust the async-await implementation it\u0026rsquo;s lazy, that means that the code will not run on the background and wait for the await, but rather run at the moment the await call asks for it. This design follows the Rust philoshopy having a better performance and error handeling.\nSo that\u0026rsquo;s it ? Well, that can be it with the basics but you have a lot more options to work asynchronously in Rust. You have multiple frameworks/runtimes, none of them are standard:\n Tokio : A popular async ecosystem with HTTP, gRPC, and tracing frameworks. async-std : A crate that provides asynchronous counterparts to standard library components. smol : A small, simplified async runtime. Provides the Async trait that can be used to wrap structs like UnixStream or TcpListener.  Each one of them have different approaches, I will choose tokio because it\u0026rsquo;s the more one that looks more popular and standard.\nCrawler boilerplatte To create a basic crawler we need the following:\n Make HTTP calls Parse HTML code Async calls system  We will be using reqwest  for the HTTP calls, html5ever  for the parsing and tokio  for the async calls.\n[dependencies] reqwest = { version = \u0026#34;0.11\u0026#34; } html5ever = \u0026#34;*\u0026#34; tokio = { version = \u0026#34;1\u0026#34;, features = [\u0026#34;full\u0026#34;] } ","permalink":"http://marcelarie.github.io/posts/my-first-post/","summary":"What is async-await ? If you just started programming async-await may feel a strange concept. For now you write code in a file and it runs in order, that is it right? But the web doesn\u0026rsquo;t work like that, all the communication that we do today its asynchronous.\nSo for example this will be synchronous code:\nfn synchronous_hello() { println!(\u0026#34;hello!\u0026#34;); } fn main() { let hello = synchronous_hello(); // \u0026#34;hello!\u0026#34; gets printed } use futures::executor::block_on; // we talk about this later :)  async fn asynchronous_hello() { println!","title":"My First Post"}]